== 2011-08-19
まずはBroadcastからServiceを起動できるようにしてみた。

== 2011-08-20
- Serviceは音が鳴っている間起動していようにするのだろう
  - 違う。SCREEN_OFFを検出するのはService。
- Serviceの起動まではAlarmManager?を使う
- Serviceが起動していない時のアプリの状態はどのように検出する？

状態変化

[シエスタウォッチOffの状態(Off)]
- アラームOn操作
- Serviceを起動
- 寝るのを待ってる状態(Standby)

[寝るのを待ってる状態(Standby)]
- アラームOff操作
- Serviceを停止
- (Off)

- ACTION_SCREEN_OFFが来る
- アラーム時刻の設定
- (Countdown)

[カウントダウン中 (Countdown)]
- ACTION_USER_PRESENTが来る
- アラーム時刻の解除
- (Standby)

- アラーム時刻が来る
- アラーム音を鳴らす
- (Alarm)

[アラームが鳴っている最中 (Alarm)]
- ACTION_SCREEN_ONが来る
- アラーム音を止める
- (Silent)

- ACTION_USER_PRESENTが来る
- アラーム音を止める
- Serviceを停止
- (Off)

[アラームを停止中 (Silent)]
- ACTION_SCREEN_OFFが来る
- アラーム音を再開する
- (Alarm)

- ACTION_USER_PRESENTが来る
- アラーム音を止める
- Serviceを停止
- (Off)

[その他」
- Acivityの起動時
  - (Off)だったら(Off)それ以外だったら(Standby)かな

ServiceがIntentを受ける必要があるね - onStart()は何度でも呼んでも
らえるようだ。Activityや自身からの電文をExtrasに入れればいいかも。

START_STICKY is used for services that are explicitly started and stopped as
needed

onStartは古い実装のようだ。onStartCommandでSTART_STICKYを返せた方が良いので
http://developer.android.com/reference/android/app/Service.html#onStartCommand%28android.content.Intent,%20int,%20int%29
より下記のようにしておく:

If you need your application to run on platform versions prior to API level 5,
you can use the following model to handle the older onStart(Intent, int)
callback in that case. The handleCommand method is implemented by you as
appropriate: 

// This is the old onStart method that will be called on the pre-2.0
// platform.  On 2.0 or later we override onStartCommand() so this
// method will not be called.
@Override
public void onStart(Intent intent, int startId) {
    handleCommand(intent);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    handleCommand(intent);
    // We want this service to continue running until it is explicitly
    // stopped, so return sticky.
    return START_STICKY;
}

